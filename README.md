# Apriori

Apriori is an algorithm for frequent item set mining and association rule learning over relational databases.
It proceeds by identifying the frequent individual items in the database and extending them to larger and larger item sets as long as those item sets appear sufficiently often in the database. The frequent item sets determined by Apriori can be used to determine association rules which highlight general trends in the database: this has applications in domains such as market basket analysis.

<pre><b>Apriori</b>(T, ε)
    L<sub>1</sub> ← {large 1 - itemsets}
    k ← 2
    <b>while</b> L<sub>k−1</sub> <b>is not</b> empty
        C<sub>k</sub> ← Apriori_gen(L<sub>k−1</sub>, k)
        <b>for</b> transactions t <b>in</b> T
            D<sub>t</sub> ← {c in C<sub>k</sub>&nbsp;: c ⊆ t}
            <b>for</b> candidates c <b>in</b> D<sub>t</sub>
                count[c] ← count[c] + 1

        L<sub>k</sub> ← {c in C<sub>k</sub>&nbsp;: count[c] ≥ ε}
        k ← k + 1

    <b>return</b> Union(L<sub>k</sub>)

<b>Apriori_gen</b>(L, k)
     result ← list()
     <b>for all</b> p ⊆ L, q ⊆ L <b>where</b> p<sub>1</sub> = q<sub>1</sub>, p<sub>2</sub> = q<sub>2</sub>, ..., p<sub>k-2</sub> = q<sub>k-2</sub> and p<sub>k-1</sub> &lt; q<sub>k-1</sub>
         c = p ∪ {q<sub>k-1</sub>}
         <b>if</b> u ⊆ c <b>for all</b> u <b>in</b> L
             result.add(c)
      <b>return</b> result
</pre>

## DB Usage

I used <a href="http://fimi.uantwerpen.be/data/kosarak.dat">Database</a> in my project and i store that data in 'kosarak.csv' in DB folder.

## CLI Usage

For run this project in your computer, you should enter below command in your cmd:
<br>
<code style="  color: crimson;  background-color: #f1f1f1; padding: 2px;  font-size: 105%;">python ./Src/apriori.py -f ./DB/kosarak.csv</code>

<article class="content post-223254 post type-post status-publish format-standard hentry category-advanced-computer-subject tag-data-mining" id="post-223254"><h1>Apriori Algorithm</h1><div class="media"><div class="meta"><ul><li><span class="strong">Difficulty Level :</span>
<span><a href="https://www.geeksforgeeks.org/medium/">Medium</a></span></li><li><span class="strong">Last Updated :</span>
<span>04 Apr, 2020</span></li></ul></div></div><div class="text"><p>Prerequisite – <a href="https://www.geeksforgeeks.org/frequent-item-set-in-data-set-association-rule-mining/" rel="noopener" target="_blank">Frequent Item set in Data set (Association Rule Mining)</a><br><strong>Apriori algorithm</strong> is given by R. Agrawal and R. Srikant in 1994 for finding frequent itemsets in a dataset for boolean association rule. Name of the algorithm is Apriori because it uses prior knowledge of frequent itemset properties. We apply an iterative approach or level-wise search where k-frequent itemsets are used to find k+1 itemsets.</p><p>To improve the efficiency of level-wise generation of frequent itemsets, an important property is used called <i>Apriori property</i> which helps by reducing the search space.</p><p><strong>Apriori Property –</strong><br>All non-empty subset of frequent itemset must be frequent. The key concept of Apriori algorithm is its anti-monotonicity of support measure. Apriori assumes that</p><blockquote><p>All subsets of a frequent itemset must be frequent(Apriori propertry).<br>If an itemset is infrequent, all its supersets will be infrequent.</p></blockquote><p>Before we start understanding the algorithm, go through some definitions which are explained in my previous post.<br>Consider the following dataset and we will find frequent itemsets and generate association rules for them.</p><br><div id="AP_G4GR_5"></div><div style="min-height:280px" id="d6f45c53-ff16-4cc5-8b91-eb6ee7037116" class="_ap_apex_ad"><script>var adpushup = window.adpushup  = window.adpushup || {que:[]};adpushup.que.push(function() {adpushup.triggerAd("d6f45c53-ff16-4cc5-8b91-eb6ee7037116");});</script></div><br><div style="vertical-align:middle;text-align:center"><img src="https://media.geeksforgeeks.org/wp-content/uploads/Capture-128.png" alt="" width="164" height="246" class="alignnone size-full wp-image-461761"><br>minimum support count is 2<br>minimum confidence is 60%</div><p><b>Step-1: </b>K=1<br>(I) Create a table containing support count of each item present in dataset – Called <strong>C1(candidate set)</strong></p><div style="vertical-align:middle;text-align:center"><img src="https://media.geeksforgeeks.org/wp-content/uploads/Capture-129.png" alt="" width="162" height="148" class="alignnone size-full wp-image-461769"></div><p>(II) compare candidate set item’s support count with minimum support count(here min_support=2 if support_count of candidate set items is less than min_support then remove those items). This gives us itemset L1.</p><div style="vertical-align:middle;text-align:center"><img src="https://media.geeksforgeeks.org/wp-content/uploads/Capture-129.png" alt="" width="162" height="148" class="alignnone size-full wp-image-461769"></div><p><b>Step-2:</b> K=2</p><ul><li>Generate candidate set C2 using L1 (this is called join step). Condition of joining L<sub>k-1</sub> and L<sub>k-1</sub> is that it should have (K-2) elements in common.</li><li>Check all subsets of an itemset are frequent or not and if not frequent remove that itemset.(Example subset of{I1, I2} are {I1}, {I2} they are frequent.Check for each itemset)</li><li>Now find support count of these itemsets by searching in dataset.<div style="vertical-align:middle;text-align:center"><img src="https://media.geeksforgeeks.org/wp-content/uploads/Capture-130.png" alt="" width="165" height="269" class="alignnone size-full wp-image-461777"></div><p>(II) compare candidate (C2) support count with minimum support count(here min_support=2 if support_count of candidate set item is less than min_support then remove those items) this gives us itemset L2.</p><div style="vertical-align:middle;text-align:center"><img src="https://media.geeksforgeeks.org/wp-content/uploads/Capture-131.png" alt="" width="163" height="198" class="alignnone size-full wp-image-461779"></div><p><b>Step-3:</b></p><ul><li>Generate candidate set C3 using L2 (join step). Condition of joining L<sub>k-1</sub> and L<sub>k-1</sub> is that it should have (K-2) elements in common. So here, for L2, first element should match.<br>So itemset generated by joining L2 is {I1, I2, I3}{I1, I2, I5}{I1, I3, i5}{I2, I3, I4}{I2, I4, I5}{I2, I3, I5}</li><li>Check if all subsets of these itemsets are frequent or not and if not, then remove that itemset.(Here subset of {I1, I2, I3} are {I1, I2},{I2, I3},{I1, I3} which are frequent. For {I2, I3, I4}, subset {I3, I4} is not frequent so remove it. Similarly check for every itemset)</li><li>find support count of these remaining itemset by searching in dataset.</li></ul><div style="vertical-align:middle;text-align:center"><img src="https://media.geeksforgeeks.org/wp-content/uploads/Capture-132.png" alt="" width="169" height="73" class="alignnone size-full wp-image-461789"></div><p>(II) Compare candidate (C3) support count with minimum support count(here min_support=2 if support_count of candidate set item is less than min_support then remove those items) this gives us itemset L3.</p><div style="vertical-align:middle;text-align:center"><img src="https://media.geeksforgeeks.org/wp-content/uploads/Capture-132.png" alt="" width="169" height="73" class="alignnone size-full wp-image-461789"></div><p><b>Step-4:</b></p><ul><li>Generate candidate set C4 using L3 (join step). Condition of joining L<sub>k-1</sub> and L<sub>k-1</sub> (K=4) is that, they should have (K-2) elements in common. So here, for L3, first 2 elements (items) should match.</li><li>Check all subsets of these itemsets are frequent or not (Here itemset formed by joining L3 is {I1, I2, I3, I5} so its subset contains {I1, I3, I5}, which is not frequent). So no itemset in C4</li><li>We stop here because no frequent itemsets are found further</li></ul><hr><br>Thus, we have discovered all the frequent item-sets. Now generation of strong association rule comes into picture. For that we need to calculate confidence of each rule.<p><b>Confidence –</b><br>A confidence of 60% means that 60% of the customers, who purchased milk and bread also bought butter.</p><p style="text-align:center"><code>Confidence(A-&gt;B)=Support_count(A∪B)/Support_count(A)</code></p><p>So here, by taking an example of any frequent itemset, we will show the rule generation.<br>Itemset {I1, I2, I3} //from L3<br>SO rules can be<br>[I1^I2]=&gt;[I3] //confidence = sup(I1^I2^I3)/sup(I1^I2) = 2/4*100=50%<br>[I1^I3]=&gt;[I2] //confidence = sup(I1^I2^I3)/sup(I1^I3) = 2/4*100=50%<br>[I2^I3]=&gt;[I1] //confidence = sup(I1^I2^I3)/sup(I2^I3) = 2/4*100=50%<br>[I1]=&gt;[I2^I3] //confidence = sup(I1^I2^I3)/sup(I1) = 2/6*100=33%<br>[I2]=&gt;[I1^I3] //confidence = sup(I1^I2^I3)/sup(I2) = 2/7*100=28%<br>[I3]=&gt;[I1^I2] //confidence = sup(I1^I2^I3)/sup(I3) = 2/6*100=33%</p><p>So if minimum confidence is 50%, then first 3 rules can be considered as strong association rules.</p><p><b>Limitations of Apriori Algorithm</b><br>Apriori Algorithm can be slow. The main limitation is time required to hold a vast number of candidate sets with much frequent itemsets, low minimum support or large itemsets i.e. it is not an efficient approach for large number of datasets. For example, if there are 10^4 from frequent 1- itemsets, it need to generate more than 10^7 candidates into 2-length which in turn they will be tested and accumulate. Furthermore, to detect frequent pattern in size 100 i.e. v1, v2… v100, it have to generate 2^100 candidate itemsets that yield on costly and wasting of time of candidate generation. So, it will check for many sets from candidate itemsets, also it will scan database many times repeatedly for finding candidate itemsets. Apriori will be very low and inefficiency when memory capacity is limited with large number of transactions. [Source : <a href="https://arxiv.org/pdf/1403.3948.pdf">https://arxiv.org/pdf/1403.3948.pdf</a>]</p><div id="personalNoteDiv" class="clear hideIt"><div class="personalNoteHeader clear">
</div><div class="collapsableDivPersonalNotes"></div></div></div></li></ul></div></article>
